// Copyright 2019 Serge 'q3k' Bazanski
// This file is licensed under a Creative Commons CC0 license
// (https://creativecommons.org/share-your-work/public-domain/cc0/)

// q3d - a boneless 3d object format for asset exchange.

// Vaguely inspired by the Lowest Common Denominator of 3d files, STL.
// This format is extensible within the bounds of what FlatBuffers offer.
// However, such exensions are fundamentally incompatible with upstream 'q3d'
// files, as extension identifiers may clash with other extensions. As such,
// we kindly ask to not claim q3d compatibility if such extensions are in use
// by your application, and instead either wrap the top-level Object in your
// own FlatBuffer IDL, or upstream your required changes.

namespace q3d;

struct Vector3 {
    x: float32;
    y: float32;
    z: float32;
}

struct UV {
    u: float32;
    v: float32;
}

table Color {
    // Red channel.
    r: ubyte (id: 0);
    // Green channel.
    g: ubyte (id: 1);
    // Blue channel.
    b: ubyte (id: 2);
    // Alpha channel. 0 is transparent, 255 is opaque.
    // This is the transparency applied to a mesh triangle during rasterization
    // rendering. Backside triangles have no opacity
    // at all. Optional.
    a: ubyte = 255 (id: 3);
}

table TextureOrValue3D {
    r: ubyte (id: 0);
    g: ubyte (id: 1);
    b: ubyte (id: 2);
    textureRef: string (id: 3);
}

table TextureOrValue1D {
    v: float32 (id: 0);
    textureRef: string (id: 1);
}

// Single-sided triangle.
table Triangle {
    // Three vertices that make up the geometry of the triangle. Required.
    // Position of vertices is in mm.
    vertex1: Vector3 (required, id: 0);
    vertex2: Vector3 (required, id: 1);
    vertex3: Vector3 (required, id: 2);

    // Consumers must use normal data in the following way:
    // 1) if all three vertex normals are given, they will be used,
    // 2) otherwise, if the face normal is given, it will be used,
    // 3) otherwise, a face normal will be calculated from trinangle verties
    //    (in counter-clockwise front-facing mode).
    // If the consumer does not support vertex normals, it can skip step 1).
    // This means that the producer is free to include either a face normal,
    // vertex normals, both or none.

    // Normal vectors do not have to be unit vectors.
    
    faceNormal: Vector3 (id: 3);
    // vertexNormal{1,2,3} correspond to vertices vertex{1,2,3}
    vertexNormal1: Vector3 (id: 4);
    vertexNormal2: Vector3 (id: 5);
    vertexNormal3: Vector3 (id: 6);

    // Texture UV coordinates for each vertex. Either all coordinates are given
    // for all vertices, or none are.
    vertexUV1: UV (id: 7);
    vertexUV2: UV (id: 8);
    vertexUV3: UV (id: 9);
}

// A Material describes the visual properties of a Mesh.
table Material {
    // Opaque identifier for material, to be displayed to human end-user by consuming
    // tool. Optional.
    name: string (id: 0);
    // Mesh color, applied to every triangle. Required. This color is used in
    // non-photorealistic shading models, like basic Blinn-Phong shading in CAD
    // software. In addition, a PBR Principled BRDF material can be defined by
    // setting parameters lower down in this table.
    color: Color (required, id: 1);

    // Principled BRDF shader parameters.
    // If these are set, this material becomes a PBR BRDF shader, and the following
    // parameters configure it. The `color` parameter is then ignored. If any parameters
    // are set, all must be set.
    //
    // Burley, B., & Studios, W. D. A. (2012, August). Physically-based shading at disney.
    // In ACM SIGGRAPH (Vol. 2012, pp. 1-7).

    pbrdfBaseColor: TextureOrValue3D (id: 2);
    pbrdfSubsurface: TextureOrValue1D (id: 3);
    pbrdfSpecular: TextureOrValue1D (id: 4);
    pbrdfSpecularTing: TextureOrValue1D (id: 5);
    pbrdfRoughness: TextureOrValue1D (id: 6);
    pbrdfAnisotropic: TextureOrValue1D (id: 7);
    pbrdfSheen: TextureOrValue1D (id: 8);
    pbrdfSheenTint: TextureOrValue1D (id: 9);
    pbrdfClearcoat: TextureOrValue1D (id: 10);
    pbrdfClearcoatGloss: TextureOrValue1D (id: 11);

    // In addition to the principled shader parameters above, the material can also define
    // a normal map texture.
    normalMapTextureRef: string (id: 12);
}

// A Mesh is a collection of Triangles that introduces material information.
table Mesh {
    // Triangles that make up the mesh. Required, can be empty (but why would
    // you do that).
    // A mesh that represents a closed volume will have all triangles fully
    // tesselated. However, this is not required nor guaranteed, and consumers
    // should not assume this.
    triangles: [Triangle] (required, id: 0);
    // Material that the mesh uses. Required.
    material: Material (required, id: 1);
}

// An Object is a collection of Meshes and the Root Type of the format.
table Object {
    // Meshes that make up the object. Required.
    meshes: [Mesh] (required, id: 0);
}

// We brand the identifier and file extensions with 'o' for object. In case
// we would also like to convey other data (either multi-object scenes, CAD
// data, ...), these can be implemented in higher-level formats sharing the
// same 'q3d' prefix family.

file_identifier "Q3DO";
file_extension "q3do";
root_type Object;
